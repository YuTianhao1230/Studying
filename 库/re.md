`re` 是 Python 内置的**正则表达式 (Regular Expression)** 模块。你可以把它想象成一个极其强大的**文本模式查找和处理工具**。普通的字符串查找只能找固定的文本，而正则表达式可以让你定义一个“模式”，然后用这个模式去匹配、查找、替换、分割任何符合该模式的文本。

---

### 一、`re` 库是用来做什么的？(核心用途)

它主要解决四类问题：

1.  **验证 (Validation)**：判断一个字符串是否符合某种格式。
    *   例如：一个字符串是不是一个合法的Email地址？是不是一个有效的手机号码？

2.  **提取 (Extraction)**：从一段文本中找出所有符合模式的内容。
    *   例如：从一个网页HTML中提取所有的URL链接。从一篇新闻中提取所有的日期。

3.  **替换 (Replacement)**：找到符合模式的文本，并将其替换成别的内容。
    *   例如：将文章中所有的 "color" 替换为 "colour"。将文本中的敏感词替换为 `***`。

4.  **分割 (Splitting)**：使用比普通 `split()` 方法更复杂的规则来分割字符串。
    *   例如：根据逗号、分号、或者空格来分割一个字符串。

---

### 二、核心概念：模式与函数

使用 `re` 库主要就是和两个东西打交道：

*   **模式 (Pattern)**：就是你定义的“规则”，用一套特殊的符号来书写。
*   **函数 (Function)**：`re` 模块提供的工具，用来执行你定义的模式。

#### 1. 常用正则表达式符号 (构建模式的积木)

| 符号 | 含义 | 示例 |
| :--- | :--- | :--- |
| `.` | 匹配**除换行符外**的任意单个字符 | `a.c` 能匹配 "abc", "a_c", "a2c" |
| `\d` | 匹配任意一个**数字** (0-9) | `\d\d` 能匹配 "23", "99" |
| `\w` | 匹配**字母、数字、下划线** | `\w\w\w` 能匹配 "cat", "h_1", "py3" |
| `\s` | 匹配任意一个**空白字符** (空格, tab, 换行) | `a\sc` 能匹配 "a c" |
| `\D`, `\W`, `\S`| 与 `\d`, `\w`, `\s` 相反，匹配**非**数字、**非**字母数字下划线、**非**空白 | `\D` 能匹配 "a", "#", " " |
| `*` | 匹配前面的子表达式 **0 次或多次** | `ab*c` 能匹配 "ac", "abc", "abbbc" |
| `+` | 匹配前面的子表达式 **1 次或多次** | `ab+c` 能匹配 "abc", "abbbc", 但**不能**匹配 "ac" |
| `?` | 匹配前面的子表达式 **0 次或 1 次** | `ab?c` 能匹配 "ac", "abc", 但**不能**匹配 "abbc" |
| `{m,n}` | 匹配前面的子表达式 **m 到 n 次** | `a{2,4}` 能匹配 "aa", "aaa", "aaaa" |
| `^` | 匹配字符串的**开头** | `^Hello` 能匹配 "Hello world", 但**不能**匹配 "Say Hello" |
| `$` | 匹配字符串的**结尾** | `world$` 能匹配 "Hello world", 但**不能**匹配 "world is big" |
| `[...]`| 匹配方括号中的**任意一个字符** | `[aeiou]` 能匹配任何一个小写元音字母 |
| `[^...]`| 匹配**不在**方括号中的任意一个字符 | `[^0-9]` 能匹配任何一个非数字字符 |
| `\|` | **或**操作符，匹配 `|` 左边或右边的表达式 | `cat\|dog` 能匹配 "cat" 或 "dog" |
| `(...)`| **分组**，将多个字符作为一个单元，也用于**捕获**匹配的内容 | `(ab)+` 能匹配 "ab", "abab" |

#### 2. 主要函数 (执行模式的工具)

假设我们有 `pattern`（模式）和 `string`（要处理的文本）。

*   **`re.match(pattern, string)`**
    *   从字符串的**开头**开始匹配。如果开头不符合模式，就立即失败返回 `None`。
    *   **用途**：适合用来检查字符串是否以某个模式开头。

*   **`re.search(pattern, string)`**
    *   **搜索整个**字符串，直到找到**第一个**成功的匹配。如果找不到，返回 `None`。
    *   返回一个“匹配对象(Match Object)”，可以用 `.group(0)` 获取整个匹配的字符串。
    *   **用途**：最常用的查找函数，用于判断字符串中是否存在某个模式。

*   **`re.findall(pattern, string)`**
    *   **搜索整个**字符串，找到**所有**不重叠的匹配。
    *   返回一个**列表**，包含所有匹配到的字符串。
    *   **用途**：非常适合用来提取所有符合模式的内容。

*   **`re.sub(pattern, repl, string)`**
    *   找到所有匹配 `pattern` 的地方，并用 `repl` (replacement) 替换它们。
    *   返回一个新的、被替换过的字符串。
    *   **用途**：用于文本替换和清洗。

*   **`re.split(pattern, string)`**
    *   用 `pattern` 作为分隔符来分割字符串。
    *   返回一个分割后的字符串列表。
    *   **用途**：当需要多种分隔符时，比 `string.split()` 更强大。

*   **`re.compile(pattern)`**
    *   将一个正则表达式模式“编译”成一个正则表达式对象。
    *   **用途**：如果一个模式需要被**反复使用**，先编译它可以大大提高程序的执行效率。

---

### 三、实用示例

#### 示例1：验证邮箱格式

```python
import re

email1 = "test.user@example.com"
email2 = "invalid-email@"

# 定义一个简单的邮箱模式
# \w+      : 匹配一个或多个字母数字下划线 (用户名)
# @        : 匹配@符号
# [\w\.]+  : 匹配一个或多个字母数字下划线或点 (域名)
pattern = r"^\w+@[\w\.]+$"

if re.match(pattern, email1):
    print(f"'{email1}' 是一个合法的邮箱格式")
else:
    print(f"'{email1}' 不是一个合法的邮箱格式")

if re.match(pattern, email2):
    print(f"'{email2}' 是一个合法的邮箱格式")
else:
    print(f"'{email2}' 不是一个合法的邮箱格式")

# 输出:
# 'test.user@example.com' 是一个合法的邮箱格式
# 'invalid-email@' 不是一个合法的邮箱格式
```

#### 示例2：从文本中提取所有电话号码

```python
import re

text = "我的电话是 138-1234-5678, 备用号码是 186-8765-4321, 办公室电话是 010-8888-9999"

# 定义电话号码模式
# \d{3,4}  : 匹配3或4个数字 (区号或手机前缀)
# -        : 匹配-
# \d{4,8}  : 匹配4到8个数字 (电话号码)
pattern = r"\d{3,4}-\d{4,8}"

phone_numbers = re.findall(pattern, text)
print(f"找到的电话号码: {phone_numbers}")

# 输出:
# 找到的电话号码: ['138-1234-5678', '186-8765-4321', '010-8888-9999']
```

#### 示例3：替换敏感信息

```python
import re

text = "张三的身份证是 110101199001011234, 李四的身份证是 440101199202025678"

# 定义身份证模式，并使用分组()来捕获前后几位数字
pattern = r"(\d{6})\d{8}(\d{4})"

# repl 参数中，\1 代表第一个分组捕获的内容，\2 代表第二个
result = re.sub(pattern, r"\1********\2", text)
print(f"替换后的文本: {result}")

# 输出:
# 替换后的文本: 张三的身份证是 110101********1234, 李四的身份证是 440101********5678
```

---

### 四、最佳实践与技巧

1.  **使用原始字符串 (Raw Strings)**
    在定义模式时，总是在字符串前加上 `r` (例如 `r"\d+"`)。这可以防止 Python 将 `\` 解释为转义字符，从而避免很多不必要的错误。

2.  **使用 `re.compile()` 提高效率**
    如果你的程序中要多次使用同一个正则表达式，先编译它。
    ```python
    pattern = re.compile(r"\d+")
    # 之后就可以直接使用 pattern 对象
    result1 = pattern.findall("abc123def456")
    result2 = pattern.findall("ghi789jkl0")
    ```

3.  **理解贪婪模式 (Greedy) vs. 非贪婪模式 (Non-greedy)**
    默认情况下，`*` 和 `+` 是“贪婪的”，它们会尽可能多地匹配字符。在它们后面加上 `?` 可以使其变为“非贪婪”，即尽可能少地匹配。
    ```python
    text = "<h1>标题一</h1><h1>标题二</h1>"
    
    # 贪婪模式，会从第一个<h1>匹配到最后一个</h1>
    print(re.findall(r"<h1>.*</h1>", text)) 
    # -> ['<h1>标题一</h1><h1>标题二</h1>']

    # 非贪婪模式，匹配到第一个</h1>就停止
    print(re.findall(r"<h1>.*?</h1>", text))
    # -> ['<h1>标题一</h1>', '<h1>标题二</h1>']
    ```

正则表达式是一个博大精深的主题，但掌握了以上这些核心内容，你已经可以解决绝大多数日常编程中遇到的文本处理问题了。
